ticker()
	while alive:
		lock()
		state = getState()
		unlock()

		if state == candidate {
			go rf.startElection()
		} else if state == leader {
			go rf.sendBroadcast()
		}
		select:
			heartbeatChannel:
				// received a successful append entry from the leader
				// append entry function should step down to follower
				// and append entries to log
				if !Follower -> panic
			stepDownChannel:
				// this happens when leader receives an unsuccessful append entry due to
				// old term or old term in request vote
				// or candidate received an old term somewhere
				rf.stepDownToFollower()
			wonElectonChannel:
				rf.stepUpToLeader()
			killChannel:
				break
			timoutChannel:
				// if state == follower {
					// didnt receive heartbeat so should become a candidate
					rf.stepUpToCandidate()
				}

stepUpToCandidate():
	lock()
	defer unlock()

	currentTerm++
	state = candidate
	votedFor = me

stepUpToLeader():
	lock()
	defer unlock()
	state = leader

stepDownToFollower(newTerm)
	lock()
	defer unlock()
	state = follower
	votedFor = -1
	term = newTerm

RequestArgs()
	lock()
	defer unlock()
	reply.term = term
	if term > args.Term {
		// this is an old term
		reply.success = false
	} else if votedFor == -1 && upToDate(args) {
			reply.success = true
			go func(){
				stepDownChannel <- true
			}() // if this isn't inside a go routine a deadlock will happen
			// or make channels with buffer of size 1
		} else {
		reply.success= false
	}

AppendEntries():
	lock()
	defer unlock()

	reply.term = term
	if args.term < term {
		return reply.success = false
	}

	// TODO handle commit index > last applied

	// 3. If an existing entry conflicts with a new one (same index
	// but different terms), delete the existing entry and all that
	// follow it (§5.3)

	// If leaderCommit > commitIndex, set commitIndex =
	// min(leaderCommit, index of last new entry)

	// If there exists an N such that N > commitIndex, a majority
	// of matchIndex[i] ≥ N, and log[N].term == currentTerm:
	// set commitIndex = N (§5.3, §5.4).

	// If AppendEntries fails because of log inconsistency:
	// decrement nextIndex and retry (§5.3)
	//
	// If successful: update nextIndex and matchIndex for
	// follower (§5.3)
